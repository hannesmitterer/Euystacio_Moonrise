<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Euystacio â€” Dynamic Connect v2.0</title>
  <style>
    body { 
      font-family: sans-serif; 
      padding: 2rem; 
      background: #111; 
      color: #eee; 
      text-align: center; 
      line-height: 1.6;
    }
    .container { max-width: 800px; margin: 0 auto; }
    form { 
      margin: 1rem auto; 
      max-width: 400px; 
      background: #222; 
      padding: 1rem; 
      border-radius: 6px; 
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    input, button { 
      width: 90%; 
      margin: 0.5rem 0; 
      padding: 0.5rem; 
      border-radius: 6px; 
      border: none; 
      font-size: 14px;
    }
    button { 
      background: #f55; 
      color: #fff; 
      cursor: pointer; 
      transition: background 0.3s;
    }
    button:hover { background: #ff8888; }
    button:disabled { 
      background: #666; 
      cursor: not-allowed; 
    }
    canvas { 
      max-width: 600px; 
      margin: 2rem auto; 
      display: block; 
      border-radius: 6px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    
    /* Status and error display */
    .status-panel {
      background: #333;
      border-radius: 6px;
      padding: 1rem;
      margin: 1rem auto;
      max-width: 600px;
      text-align: left;
    }
    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }
    .status-item {
      background: #444;
      padding: 0.5rem;
      border-radius: 4px;
    }
    .status-label { 
      font-weight: bold; 
      color: #0ff; 
      font-size: 0.9em;
    }
    .status-value { 
      font-size: 1.1em; 
      margin-top: 0.2rem;
    }
    
    /* Error and message display */
    .message-container {
      position: fixed;
      top: 20px;
      right: 20px;
      max-width: 300px;
      z-index: 1000;
    }
    .message {
      background: #333;
      border-left: 4px solid #f55;
      padding: 1rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }
    .message.show { transform: translateX(0); }
    .message.success { border-left-color: #5f5; }
    .message.warning { border-left-color: #ff5; }
    .message.info { border-left-color: #0ff; }
    
    /* Connection status */
    .connection-status {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.9em;
      font-weight: bold;
    }
    .connection-status.connected {
      background: rgba(85, 255, 85, 0.2);
      color: #5f5;
      border: 1px solid #5f5;
    }
    .connection-status.disconnected {
      background: rgba(255, 85, 85, 0.2);
      color: #f55;
      border: 1px solid #f55;
    }
    .connection-status.connecting {
      background: rgba(255, 255, 85, 0.2);
      color: #ff5;
      border: 1px solid #ff5;
    }

    /* Backend URL input */
    .backend-config {
      background: #333;
      border-radius: 6px;
      padding: 1rem;
      margin: 1rem auto;
      max-width: 600px;
    }
    .backend-config input {
      width: 70%;
      display: inline-block;
      margin-right: 0.5rem;
    }
    .backend-config button {
      width: 25%;
      display: inline-block;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŒ‘ Euystacio â€” Dynamic Pulse Log v2.0</h1>
    
    <!-- Connection Status -->
    <div id="connection-status" class="connection-status disconnected">
      ðŸ”´ Disconnected
    </div>
    
    <!-- Message Container -->
    <div id="message-container" class="message-container"></div>
    
    <!-- Backend Configuration -->
    <div class="backend-config">
      <h3>Backend Configuration</h3>
      <input type="url" id="https://euystacio-moonrise.onrender.com/" placeholder="https://euystacio-moonrise.onrender.com/ (e.g., https://euystacio-moonrise.onrender.com/.onrender.com)">
      <button onclick="updateBackendUrl()">Update</button>
      <div style="margin-top: 0.5rem; font-size: 0.9em; color: #aaa;">
        Current: <span id="current-backend-url">Loading...</span>
      </div>
    </div>

    <!-- Login Form -->
    <form id="login-form">
      <h2>Login</h2>
      <input type="text" id="username" placeholder="Username" required>
      <input type="password" id="password" placeholder="Password" required>
      <button type="submit">Login</button>
      <div id="login-status"></div>
    </form>

    <!-- Pulse Form -->
    <form id="pulse-form" style="display: none;">
      <h2>Send Pulse</h2>
      <input type="text" id="event" placeholder="Event" required>
      <input type="number" id="sentiment" step="0.01" min="-1" max="1" placeholder="Sentiment (-1 to 1)" required>
      <button type="submit" id="pulse-submit">Send Pulse</button>
    </form>

    <!-- Status Panel -->
    <div id="status-panel" class="status-panel" style="display: none;">
      <h3>System Status</h3>
      <div class="status-grid" id="status-grid">
        <!-- Status items will be populated here -->
      </div>
    </div>

    <!-- Chart -->
    <canvas id="pulseChart" style="display: none;"></canvas>
  </div>

  <!-- Load configuration first -->
  <script src="config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Enhanced Euystacio Frontend v2.0
    class EuystacioClient {
      constructor() {
        this.config = window.EuystacioConfig;
        this.backendUrl = this.config.backend.url;
        this.isLoggedIn = false;
        this.chart = null;
        this.connectionStatus = 'disconnected';
        this.retryCount = 0;
        this.sessionStartTime = Date.now();
        
        this.init();
      }
      
      init() {
        this.updateConnectionStatus('connecting');
        this.updateCurrentBackendUrl();
        this.setupEventListeners();
        this.attemptBackendDiscovery();
        this.loadInitialData();
        
        // Set up periodic health checks
        setInterval(() => this.healthCheck(), 30000);
        
        // Set up session timeout check
        setInterval(() => this.checkSessionTimeout(), 60000);
      }
      
      setupEventListeners() {
        document.getElementById('login-form').addEventListener('submit', (e) => {
          e.preventDefault();
          this.handleLogin();
        });
        
        document.getElementById('pulse-form').addEventListener('submit', (e) => {
          e.preventDefault();
          this.handlePulseSubmit();
        });
        
        document.getElementById('backend-url').addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            this.updateBackendUrl();
          }
        });
      }
      
      async attemptBackendDiscovery() {
        if (!this.config.features.autoDiscovery) return;
        
        const urlsToTry = [this.backendUrl, ...this.config.backend.fallbackUrls];
        
        for (const url of urlsToTry) {
          try {
            const response = await this.fetchWithTimeout(`${url}${this.config.endpoints.info}`, {
              method: 'GET',
              headers: { 'Accept': 'application/json' }
            });
            
            if (response.ok) {
              const data = await response.json();
              this.backendUrl = url;
              this.updateConnectionStatus('connected');
              this.updateCurrentBackendUrl();
              
              this.showMessage(`Connected to ${data.name} ${data.version}`, 'success');
              return;
            }
          } catch (error) {
            // Continue to next URL
          }
        }
        
        this.updateConnectionStatus('disconnected');
        this.showMessage('Failed to connect to backend', 'error');
      }
      
      updateCurrentBackendUrl() {
        document.getElementById('current-backend-url').textContent = this.backendUrl;
        document.getElementById('backend-url').value = this.backendUrl;
      }
      
      updateConnectionStatus(status) {
        this.connectionStatus = status;
        const statusEl = document.getElementById('connection-status');
        
        statusEl.className = `connection-status ${status}`;
        
        switch (status) {
          case 'connected':
            statusEl.innerHTML = 'ðŸŸ¢ Connected';
            break;
          case 'connecting':
            statusEl.innerHTML = 'ðŸŸ¡ Connecting...';
            break;
          case 'disconnected':
            statusEl.innerHTML = 'ðŸ”´ Disconnected';
            break;
        }
      }
      
      async fetchWithTimeout(url, options = {}, timeout = this.config.backend.timeout) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        try {
          const response = await fetch(url, {
            ...options,
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          return response;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error.name === 'AbortError') {
            throw new Error('Request timeout');
          }
          throw error;
        }
      }
      
      async retryRequest(requestFn, maxRetries = this.config.backend.maxRetries) {
        for (let i = 0; i <= maxRetries; i++) {
          try {
            const result = await requestFn();
            this.retryCount = 0; // Reset on success
            return result;
          } catch (error) {
            if (i === maxRetries) {
              throw error;
            }
            
            this.retryCount = i + 1;
            const delay = this.config.backend.retryDelay * Math.pow(2, i); // Exponential backoff
            await new Promise(resolve => setTimeout(resolve, delay));
            
            this.showMessage(`Retry ${i + 1}/${maxRetries}...`, 'warning');
          }
        }
      }
      
      showMessage(text, type = 'info', duration = this.config.ui.errorDisplay.duration) {
        const container = document.getElementById('message-container');
        
        // Limit number of messages
        const existingMessages = container.children;
        if (existingMessages.length >= this.config.ui.errorDisplay.maxErrors) {
          container.removeChild(existingMessages[0]);
        }
        
        const message = document.createElement('div');
        message.className = `message ${type}`;
        message.innerHTML = `<div style="font-weight: bold;">${type.toUpperCase()}</div><div>${text}</div>`;
        
        container.appendChild(message);
        
        // Show message
        setTimeout(() => message.classList.add('show'), 100);
        
        // Hide and remove message
        setTimeout(() => {
          message.classList.remove('show');
          setTimeout(() => {
            if (message.parentNode) {
              container.removeChild(message);
            }
          }, 300);
        }, duration);
      }
      
      async handleLogin() {
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        const statusEl = document.getElementById('login-status');
        
        const defaultUser = this.config.auth.defaultUser;
        
        if (username === defaultUser.username && password === defaultUser.password) {
          this.isLoggedIn = true;
          this.sessionStartTime = Date.now();
          
          statusEl.innerHTML = 'âœ… Tutor Login Successful!';
          statusEl.style.color = '#5f5';
          
          document.getElementById('pulse-form').style.display = 'block';
          document.getElementById('status-panel').style.display = 'block';
          document.getElementById('pulseChart').style.display = 'block';
          
          this.showMessage('Login successful! Welcome back.', 'success');
          this.loadPulses();
          this.startPeriodicUpdates();
        } else {
          statusEl.innerHTML = 'âŒ Invalid credentials';
          statusEl.style.color = '#f55';
          this.showMessage('Invalid username or password', 'error');
        }
      }
      
      checkSessionTimeout() {
        if (this.isLoggedIn) {
          const elapsed = Date.now() - this.sessionStartTime;
          if (elapsed > this.config.auth.sessionTimeout) {
            this.logout('Session expired');
          }
        }
      }
      
      logout(reason = 'Logged out') {
        this.isLoggedIn = false;
        document.getElementById('pulse-form').style.display = 'none';
        document.getElementById('status-panel').style.display = 'none';
        document.getElementById('pulseChart').style.display = 'none';
        document.getElementById('login-status').innerHTML = '';
        
        this.showMessage(reason, 'info');
      }
      
      async handlePulseSubmit() {
        if (!this.isLoggedIn) {
          this.showMessage('Please log in first', 'warning');
          return;
        }
        
        const event = document.getElementById('event').value;
        const sentiment = parseFloat(document.getElementById('sentiment').value);
        const submitBtn = document.getElementById('pulse-submit');
        
        if (isNaN(sentiment) || sentiment < -1 || sentiment > 1) {
          this.showMessage('Sentiment must be between -1 and 1', 'error');
          return;
        }
        
        submitBtn.disabled = true;
        submitBtn.textContent = 'Sending...';
        
        try {
          await this.retryRequest(async () => {
            const response = await this.fetchWithTimeout(`${this.backendUrl}${this.config.endpoints.pulse}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                event,
                sentiment,
                role: 'tutor',
                user: this.config.auth.defaultUser.username,
                timestamp: new Date().toISOString()
              })
            });
            
            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.error || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            if (this.config.features.showMetrics && data.kernel) {
              this.updateStatus(data.kernel);
            }
            
            return data;
          });
          
          this.showMessage('Pulse sent successfully!', 'success');
          document.getElementById('pulse-form').reset();
          this.loadPulses();
          this.updateConnectionStatus('connected');
          
        } catch (error) {
          this.showMessage(`Failed to send pulse: ${error.message}`, 'error');
          this.updateConnectionStatus('disconnected');
        } finally {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Send Pulse';
        }
      }
      
      async loadInitialData() {
        try {
          await this.healthCheck();
        } catch (error) {
          if (this.config.features.debugMode) {
            console.warn('Initial health check failed:', error);
          }
        }
      }
      
      async healthCheck() {
        try {
          const response = await this.fetchWithTimeout(`${this.backendUrl}${this.config.endpoints.status}`);
          
          if (response.ok) {
            const data = await response.json();
            this.updateConnectionStatus('connected');
            
            if (this.config.features.showMetrics) {
              this.updateSystemStatus(data);
            }
            
            return true;
          } else {
            throw new Error(`Health check failed: ${response.status}`);
          }
        } catch (error) {
          this.updateConnectionStatus('disconnected');
          return false;
        }
      }
      
      updateSystemStatus(data) {
        const statusGrid = document.getElementById('status-grid');
        
        const statusItems = [
          { label: 'Status', value: data.status || 'Unknown' },
          { label: 'Pulse Count', value: data.pulse_count || 0 },
          { label: 'Balance Metric', value: (data.balance_metric || 0).toFixed(3) },
          { label: 'Learning Rate', value: (data.learning_rate || 0).toFixed(3) },
          { label: 'Memory Usage', value: data.memory_usage || 'N/A' },
          { label: 'Total Inputs', value: data.total_inputs || 0 }
        ];
        
        statusGrid.innerHTML = statusItems.map(item => `
          <div class="status-item">
            <div class="status-label">${item.label}</div>
            <div class="status-value">${item.value}</div>
          </div>
        `).join('');
      }
      
      updateStatus(kernelData) {
        const statusGrid = document.getElementById('status-grid');
        
        const statusItems = [
          { label: 'Balance Metric', value: (kernelData.balance_metric || 0).toFixed(3) },
          { label: 'Learning Rate', value: (kernelData.learning_rate || 0).toFixed(3) },
          { label: 'Volatility', value: (kernelData.volatility || 0).toFixed(3) },
          { label: 'Adaptation Score', value: (kernelData.adaptation_score || 0).toFixed(3) },
          { label: 'Memory Size', value: kernelData.memory_size || 0 },
          { label: 'Prediction Error', value: (kernelData.average_error || 0).toFixed(3) }
        ];
        
        statusGrid.innerHTML = statusItems.map(item => `
          <div class="status-item">
            <div class="status-label">${item.label}</div>
            <div class="status-value">${item.value}</div>
          </div>
        `).join('');
      }
      
      async loadPulses() {
        try {
          const response = await this.fetchWithTimeout(`${this.backendUrl}${this.config.endpoints.log}?limit=${this.config.ui.chart.maxDataPoints}`);
          
          if (!response.ok) {
            throw new Error(`Failed to load pulses: ${response.status}`);
          }
          
          const result = await response.json();
          const data = result.entries || result; // Handle both new and old response formats
          
          this.updateChart(data);
          
        } catch (error) {
          this.showMessage(`Failed to load pulse data: ${error.message}`, 'error');
        }
      }
      
      updateChart(data) {
        const ctx = document.getElementById('pulseChart').getContext('2d');
        
        if (this.chart) {
          this.chart.destroy();
        }
        
        const chartData = data.slice(-this.config.ui.chart.maxDataPoints);
        
        this.chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: chartData.map(p => new Date(p.timestamp).toLocaleTimeString()),
            datasets: [{
              label: 'Pulse Sentiment',
              data: chartData.map(p => p.sentiment),
              borderColor: this.config.ui.chart.colors.primary,
              backgroundColor: this.config.ui.chart.colors.background,
              fill: true,
              tension: 0.4,
              pointRadius: 3,
              pointHoverRadius: 6
            }]
          },
          options: {
            responsive: true,
            animation: {
              duration: this.config.ui.chart.animationDuration
            },
            scales: {
              y: {
                min: -1,
                max: 1,
                grid: { color: '#333' },
                ticks: { color: '#aaa' }
              },
              x: {
                grid: { color: '#333' },
                ticks: { color: '#aaa' }
              }
            },
            plugins: {
              legend: {
                labels: { color: '#eee' }
              }
            }
          }
        });
      }
      
      startPeriodicUpdates() {
        setInterval(() => {
          if (this.isLoggedIn) {
            this.loadPulses();
          }
        }, this.config.ui.refreshInterval);
      }
    }
    
    // Global functions
    function updateBackendUrl() {
      const newUrl = document.getElementById('backend-url').value.trim();
      if (newUrl && newUrl !== client.backendUrl) {
        client.backendUrl = newUrl;
        client.updateCurrentBackendUrl();
        client.showMessage('Backend URL updated. Reconnecting...', 'info');
        client.attemptBackendDiscovery();
      }
    }
    
    // Initialize client when page loads
    let client;
    document.addEventListener('DOMContentLoaded', () => {
      client = new EuystacioClient();
    });
  </script>
</body>
</html>
